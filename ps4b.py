# Problem Set 4B
# Name: Alex B
# Collaborators: None char(Tilde,126)->shift by +1 to char(Space,32): 31+abs((126+1)-126)%95
# char "Y"(89) shift by -107 to char "M"(77): 127-abs((89-107)-32)%95

import random


class Message(object):
    def __init__(self, input_text):
        """
        Initializes a Message object

        input_text (string): the message's text

        a Message object has one attribute:
            the message text
        """
        self._input_text = input_text

    def __repr__(self):
        """
        Returns a human readable representation of the object
        DO NOT CHANGE

        Returns: (string) A representation of the object
        """
        return f"""Message('{self.get_text()}')"""

    def get_text(self):
        """
        Used to access the message text outside of the class

        Returns: (string) the message text
        """
        return str(self._input_text)

    def shift_char(self, char, shift):
        """
        Used to shift a character as described in the pset handout

        char (string): the single character to shift.
                    ASCII value in the range: 32<=ord(char)<=126
        shift (int): the amount to shift char by

        Returns: (string) the shifted character with ASCII value in the range [32, 126]
        """
        self._char = char
        self._char_order = ord(self._char)
        self._shift = shift
        self._char_new_order = self._char_order + self._shift
        if self._char_new_order > 126:
            self._char_new_order = 31 + abs(self._char_new_order - 126) % 95
        elif self._char_new_order < 32:
            self._char_new_order = 127 - abs(self._char_new_order - 32) % 95
        return chr(self._char_new_order)

    def apply_pad(self, pad):
        """
        Used to calculate the ciphertext produced by applying a one time pad to the message text.
        For each character in the text at index i shift that character by
            the amount specified by pad[i]

        pad (list of ints): a list of integers used to encrypt the message text
                        len(pad) == len(the message text)

        Returns: (string) The ciphertext produced using the one time pad
        """
        self._pad = pad
        self._ciphertext = ""
        for i in range(len(self._pad)):
            self._ciphertext += self.shift_char(
                self._input_text[i], self._pad[i]
            )
        return self._ciphertext


class PlaintextMessage(Message):
    def __init__(self, input_text, pad=None):
        """
        Initializes a PlaintextMessage object.

        input_text (string): the message's text
        pad (list of ints OR None): the pad to encrypt the input_text or None if left empty
            if pad is not None then len(pad) == len(self.input_text)

        A PlaintextMessage object inherits from Message. It has three attributes:
            the message text
            the pad (list of integers, determined by pad
                or generated randomly using self.generate_pad() if pad is None)
            the ciphertext (string, input_text encrypted using the pad)
        """
        super().__init__(input_text)
        if pad != None:
            self._pad = pad[:]
        else:
            self._pad = self.generate_pad()[:]
        self._ciphertext = self.apply_pad(self._pad)

    def __repr__(self):
        """
        Returns a human readable representation of the object
        DO NOT CHANGE

        Returns: (string) A representation of the object
        """
        return f"""PlaintextMessage('{self.get_text()}', {self.get_pad()})"""

    def generate_pad(self):
        """
        Generates a one time pad which can be used to encrypt the message text.

        The pad should be generated by making a new list and for each character
            in the message chosing a random number in the range [0, 110) and
            adding that number to the list.

        Returns: (list of integers) the new one time pad
        """
        self._gpad = []
        for i in range(len(self._input_text)):
            self._gpad.append(random.randint(0, 109))
        return self._gpad

    def get_pad(self):
        """
        Used to safely access your one time pad outside of the class

        Returns: (list of integers) a COPY of your pad
        """
        return self._pad[:]

    def get_ciphertext(self):
        """
        Used to access the ciphertext produced by applying pad to the message text

        Returns: (string) the ciphertext
        """
        return str(self._ciphertext)

    def change_pad(self, new_pad):
        """
        Changes the pad used to encrypt the message text and updates any other
        attributes that are determined by the pad.

        new_pad (list of ints): the new one time pad that should be associated with this message.
            len(new_pad) == len(the message text)

        Returns: nothing
        """
        self._pad = new_pad
        self._ciphertext = self.apply_pad(self._pad)


class EncryptedMessage(Message):
    def __init__(self, input_text):
        """
        Initializes an EncryptedMessage object

        input_text (string): the ciphertext of the message

        an EncryptedMessage object inherits from Message. It has one attribute:
            the message text (ciphertext)
        """
        super().__init__(input_text)
        self._ciphertext = input_text

    def __repr__(self):
        """
        Returns a human readable representation of the object
        DO NOT CHANGE

        Returns: (string) A representation of the object
        """
        return f"""EncryptedMessage('{self.get_text()}')"""

    def decrypt_message(self, pad):
        """
        Decrypts the message text that was encrypted with pad as described in the writeup

        pad (list of ints): the new one time pad used to encrypt the message.
            len(pad) == len(the message text)

        Returns: (PlaintextMessage) the decrypted message (containing the pad)
        """
        self._pad = pad
        self._neg_pad = [-x for x in self._pad]
        self._plaintext = self.apply_pad(self._neg_pad)
        self._pm = PlaintextMessage(self._plaintext, self._pad)
        return self._pm
